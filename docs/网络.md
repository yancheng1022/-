[1. ddos攻击？](#1)

[2. TCP和UDP的区别？](#2)

[3. TCP可靠性的保证](#3)

[4. TCP拥塞控制？](#4)

[5. tcp滑动窗口机制](#5)

[6. tcp三次握手？](#6)

[7. TCP四次挥手？](#7)

[8. 为什么是三次握手？为什么是四次挥手？](#8)

[9. HTTPS工作原理？](#9)

[10. HTTPS和HTTP的区别？](#10)

[11. osi七层模型？](#11)

[12. HTTP状态码？](#12)

[13. cookie原理？](#13)

[14. session原理？](#14)



### <span id="1">1.ddos攻击？</span>

​	Distributed Denial of service，分布式拒绝服务。多个位置同时向一个目标发起攻击

​	（1）TCP SYN泛洪攻击：客户端发送SYN数据包，服务器端分配一个进程控制块，并向客户端发送一个SYN ack，但客户端并不响应ACK，TCP连接将一直处于半开状态。服务器消耗很大

​	（2）UDP flood：UDP是没有连接状态的报文，因此可以大量发送到某端口，对于在使用的端口会影响使用，没有使用的端口会因为要回送icmp报文，影响性能

​	（3）Smurf：数据包中的源地址伪装为被攻击的ip地址，向站点广播地址发送一个icpm ping的请求，广播地址接收到后会广播到网络中的所有主机，这些主机会向被攻击的主机响应。

​	怎样防范ddos？（1）使用负载均衡 （2）路由器上禁用icmp



### <span id="2">2. TCP和UDP的区别？</span>

​	（1）TCP是面向连接，UDP是无连接 所以对系统资源要求TCP高，UDP低

​	（2）TCP保证可靠性,UDP可能丢包

​	（3）TCP保证顺序，UDP不保证

​	（4）TCP速度慢，UDP速度快（直播）



### <span id="3">3. TCP可靠性的保证？</span>

​	（1）校验和：TCP首部16位校验和字段（TCP必须 UDP可选）

​	（2）序列号：TCP将每个字节的数据进行编号，这样可以保证有序性

​	（3）确认应答：每个ACK都有对应的确认序号，告诉发送方接收到哪些数据

​	（4）超时重传：第一次500ms得不到ack重传，然后2*500   4*500  



### <span id="4">4. TCP拥塞控制？</span>

​	（1）慢开始：开始时窗口大小为1，每次得到应答时窗口加倍

​	（2）拥塞避免：窗口大于慢开始门限时每次拥塞窗口加1而不是加倍

​	（3）快重传：收到失序报文后进行重复确认（没收到M3重复确认M2），连续三次后立即重传

​	（4）快恢复：慢开始门限减半，执行拥塞避免算法



### <span id="5">5. TCP滑动窗口机制？</span>

​	TCP会话双方各自维持一个发送窗口和接收窗口。

​	（1）发送窗口只有收到窗口内字节的ack确定，才会移动发送窗口的左边界

​	（2）接收窗口只有在前面的所有段都确认的情况下才会移动左边界。（以确保对端对这些数据重传）



### <span id="6">6. TCP三次握手？</span>

​	（1）建立连接，客户端发送SYN到服务器，并进入SYN_SEND状态，等待服务器确认

​	（2）服务器确认客户的SYN，同时自己也发送一个SYN包，即SYN+ACK，服务器进入SYN_RECV状态

​	（3）客户端收到服务器SYN+ACK，向服务器发出确认包ACK，客户端和服务器进入ESTABLISHED状态



### <span id="6">7. TCP四次挥手?</span>

​	（1）客户端发送FIN报文，关闭客户端到服务器端数据连接，进入FIN_WAIT_1状态

​	（2）服务器端收到FIN后发送一个ACK给客户端，进入CLOSE_WAIT状态

​	（3）服务器端发送一个FIN报文，关闭服务器到客户端数据连接，进入LAST-ACK状态

​	（4）客户端收到FIN后，进入TIME_WAIT，接着发送一个ACK给服务器，服务器进入close状态



### <span id="8">8. 为什么是三次握手？为什么是四次挥手？</span>

​	三次握手：可以保证双方都有收发数据的能力

​	四次挥手：TCP是全双工，对方发送FIN报文表示对方没有数据要发送了。但你可能还有数据要发送，所以ACK和FIN报文分开发送



### <span id="9">9. HTTPS工作原理</span>

​	（1）浏览器向服务器443端口发起请求，携带了浏览器支持的加密算法

​	（2）服务器将数字证书返回给浏览器（认证机构对公钥进行数字签名，形成证书）

​	（3）客户端收到数字证书后，进入数字证书认证环节：检验证书合法性（内置证书列表索引） 检验是否被篡改（证书内容做hash与证书签名对比，一样则未被篡改）

​	（4）客户端生成随机数R，用网站公钥对R加密，将R传给服务器

​	（5）服务器以R为密钥对网页内容加密，传给浏览器

​	（6）浏览器以R为密钥解密获取网页内容



### <span id="10">10. HTTP和HTTPS的区别？</span>

​	（1）https需要申请证书，http不需要

​	（2）https密文传输，http明文传输

​	（3）https 443 http80



### <span id="11">11. OSI七层模型</span>

​	物理层：以二进制的数据形式在物理媒体上传输数据   （IEEE802.1）

​	数据链路层：传输有地址的帧              （arp ppp）

​	网络层：为数据包选择路由                （ip  ospf rip  bgp）

​	传输层：提供端到端的连接               （tcp udp）

​	会话层：解除或建立与其它节点的连接

​	表示层：数据格式转换，数据加密

​	应用层：文件服务，虚拟终端            （http，ftp）



### <span id="12">12. HTTP状态码？</span>

​	200：正常

​	301：永久重定向

​	302：临时重定向

​	400：请求语法错误

​	401：请求未经授权

​	403：拒绝提供服务

​	404：请求资源不存在

​	500：服务器发生不可预期错误

​	503：服务器当前不能处理客户端请求，一段时间后可能恢复正常



### <span id="13">13. cookie原理？</span>

​	Web服务器通过在http响应消息中增加set-cookie响应头字段将cookie信息发送给浏览器，浏览器端将cookie信息存储起来。浏览器通过在请求头中增加cookie请求头将cookie回传给web服务器（浏览器一般只允许存放300个cookie，每个站点最多存20个cookie，cookie限制大小4kb）



### <span id="14">14. session原理？</span>

​	Session是基于cookie技术实现的，请求到达服务器，服务器为用户创建session，生成一个sessionId，通过set-cookie响应头返回给浏览器，浏览器再次请求时携带该sessionid，服务器根据sessionid找到对应session对象